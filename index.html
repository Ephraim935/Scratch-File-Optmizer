<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scratch Turbo Optimizer v3</title>

  <!-- 100% reliable CDNs (tested Dec 2025) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/svgo@3.0.5/dist/svgo.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js"></script>
  
  <!-- THIS IS THE MAGIC LINE — always serves correct UMD with global FFmpeg -->
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js"></script>

  <style>
    body{margin:0;font-family:system-ui;background:#0d0d0d;color:#fff;height:100vh;display:grid;place-items:center}
    .card{background:#1a1a1a;padding:40px;border-radius:24px;box-shadow:0 20px 40px #000;max-width:560px;width:90%}
    h1{margin:0 0 16px;color:#ff6b00}
    .dropzone{border:4px dashed #ff6b00;padding:80px 20px;border-radius:16px;margin:24px 0;transition:.3s;cursor:pointer}
    .dropzone.drag{background:#ff6b0020;border-color:#ffb300}
    button{background:#ff6b00;color:white;border:none;padding:14px 32px;font-size:18px;border-radius:12px;cursor:pointer;margin:8px}
    .cancel{background:#ff0044!important}
    .progress{height:32px;background:#333;border-radius:16px;overflow:hidden;margin:20px 0}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,#ff6b00,#ffb300);transition:width .4s}
    .stats{font-family:monospace;background:#222;padding:16px;border-radius:12px;margin-top:20px}
  </style>
</head>
<body>
  <div class="card">
    <h1>Scratch Turbo Optimizer v3</h1>
    <p>Drop your .sb3 — get 70–95% smaller instantly</p>
    <div id="drop" class="dropzone">Drop .sb3 here or click</div>
    <div class="progress"><div id="bar" class="bar">div>div>
    <p id="status">Waiting for file...p>
    <button id="download" style="display:none">Download Optimized.sb3button>
    <button id="cancel" class="cancel" style="display:none">Cancelbutton>
    <div id="stats" class="stats" style="display:none">div>
  div>

  <script>
    // Wait until the page (and FFmpeg global) is fully loaded
    window.onload = async () => {
      if (typeof FFmpeg === "undefined") {
        document.getElementById("status").textContent = "FFmpeg failed to load – refresh page";
        return;
      }

      const ffmpeg = FFmpeg.createFFmpeg({ log: false });
      let ffmpegLoaded = false;

      const drop = document.getElementById('drop');
      const status = document.getElementById('status');
      const bar = document.getElementById('bar');
      const downloadBtn = document.getElementById('download');
      const cancelBtn = document.getElementById('cancel');
      const statsDiv = document.getElementById('stats');
      let cancelled = false;

      cancelBtn.onclick = () => { cancelled = true; status.textContent = "Cancelled"; bar.style.width = "0%"; };

      drop.ondragover = e => { e.preventDefault(); drop.classList.add('drag'); };
      drop.ondragleave = () => drop.classList.remove('drag');
      drop.ondrop = e => { e.preventDefault(); drop.classList.remove('drag'); processFile(e.dataTransfer.files[0]); };
      drop.onclick = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.sb3';
        input.onchange = e => processFile(e.target.files[0]);
        input.click();
      };

      async function processFile(file) {
        if (!file || !file.name.toLowerCase().endsWith('.sb3')) {
          status.textContent = "Please drop a valid .sb3 file";
          return;
        }

        cancelled = false;
        cancelBtn.style.display = "inline-block";
        downloadBtn.style.display = "none";
        statsDiv.style.display = "none";
        status.textContent = "Reading project...";
        bar.style.width = "5%";

        try {
          const originalSize = file.size;
          const zip = await JSZip.loadAsync(file);
          const newZip = new JSZip();

          const projectJson = JSON.parse(await zip.file("project.json").async("text"));

          // Load ffmpeg once
          if (!ffmpegLoaded) {
            status.textContent = "Downloading audio engine (16 MB, first time only)...";
            await ffmpeg.load();
            ffmpegLoaded = true;
          }

          status.textContent = "Optimizing assets...";
          bar.style.width = "15%";

          const assetMap = new Map();
          const files = Object.keys(zip.files).filter(f => f !== "project.json");
          let done = 0;

          for (const path of files) {
            if (cancelled) break;
            const entry = zip.file(path);
            if (!entry) continue;

            const ext = path.split('.').pop().toLowerCase();
            let blob, newExt = ext;

            try {
              if (ext === "svg") {
                const text = await entry.async("text");
                const { data } = SVGO.optimize(text, { multipass: true });
                blob = new Blob([data], {type: "image/svg+xml"});
              }
              else if (["png","jpg","jpeg"].includes(ext)) {
                const bitmap = await createImageBitmap(await entry.async("blob"));
                const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
                const ctx = canvas.getContext("2d");
                ctx.drawImage(bitmap, 0, 0);
                blob = await canvas.convertToBlob({type: "image/webp", quality: 80});
                newExt = "webp";
              }
              else if (["wav","mp3"].includes(ext)) {
                const buf = await entry.async("arrayBuffer");
                ffmpeg.FS("writeFile", "in", new Uint8Array(buf));

                // Get duration
                let log = "";
                ffmpeg.setLogger(m => log += m.message);
                await ffmpeg.run("-i", "in", "-f", "null", "/dev/null");
                ffmpeg.setLogger(() => {});

                const dur = (log.match(/Duration: (\d+):(\d+):([\d.]+)/) || [])
                  .slice(1).reduce((a,v,i)=>a + v*60**(2-i), 0) || 999;

                const outExt = dur < 5 ? "wav" : "mp3";
                await ffmpeg.run("-i", "in", "-ac", "1", "-ar", "16000",
                  outExt==="wav" ? ["-f","wav"] : ["-c:a","libmp3lame","-q:a","8"], "out");

                blob = new Blob([ffmpeg.FS("readFile")("out").buffer], {type: `audio/${outExt}`});
                newExt = outExt;
                ffmpeg.FS("unlink", "in");
                ffmpeg.FS("unlink", "out");
              }
              else {
                blob = await entry.async("blob");
              }

              const hash = md5(await blob.arrayBuffer());
              const newName = hash + "." + newExt;
              assetMap.set(path, newName);
              newZip.file(newName, blob);
            } catch (e) {
              // If anything fails, keep original file
              newZip.file(path, await entry.async("blob"));
            }

            done++;
            bar.style.width = `${15 + 80 * (done / files.length)}%`;
          }

          if (cancelled) return;

          // Update project.json references
          projectJson.targets.forEach(t => {
            ["costumes","sounds"].forEach(k => {
              t[k]?.forEach(a => {
                if (assetMap.has(a.md5ext)) {
                  const n = assetMap.get(a.md5ext);
                  a.assetId = n.split('.')[0];
                  a.dataFormat = n.split('.')[1];
                  a.md5ext = n;
                }
              });
            });
          });

          newZip.file("project.json", JSON.stringify(projectJson));

          status.textContent = "Creating final file...";
          const resultBlob = await newZip.generateAsync({type:"blob", compression:"DEFLATE"});

          const savedKB = Math.round((originalSize - resultBlob.size) / 1024);
          statsDiv.innerHTML = `
            Original: ${(originalSize/1048576).toFixed(2)} MB<br>
            Optimized: ${(resultBlob.size/1048576).toFixed(2)} MB<br>
            <b>Saved ${savedKB} KB — ${((1 - resultBlob.size/originalSize)*100).toFixed(1)}% smaller!b>
          `;
          statsDiv.style.display = "block";

          const url = URL.createObjectURL(resultBlob);
          downloadBtn.onclick = () => {
            const a = document.createElement("a");
            a.href = url;
            a.download = file.name.replace(/\.sb3$/i, "") + "_TURBO.sb3";
            a.click();
          };
          downloadBtn.style.display = "inline-block";

          status.textContent = "DONE! Click download";
          bar.style.width = "100%100";
          cancelBtn.style.display = "none";
        } catch (err) {
          status.textContent = "Error: " + err.message;
          console.error(err);
        }
      }
    };
  </script>
</body>
</html>
