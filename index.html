<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scratch Turbo Optimizer v3.1</title>

  <!-- Tiny, fast libraries only -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/svgo@3.0.5/dist/svgo.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js"></script>
  <!-- Tiny Opus encoder (~180 KB gzipped) -->
  <script src="https://unpkg.com/opus-encoder@2.2.0/dist/opus-encoder.min.js"></script>

  <style>
    body{margin:0;font-family:system-ui;background:#0d0d0d;color:#fff;height:100vh;display:grid;place-items:center}
    .card{background:#1a1a1a;padding:40px;border-radius:24px;box-shadow:0 20px 40px #000;max-width:560px;width:90%}
    h1{margin:0 0 16px;color:#ff6b00}
    .dropzone{border:4px dashed #ff6b00;padding:80px 20px;border-radius:16px;margin:24px 0;transition:.3s;cursor:pointer;text-align:center;font-size:18px}
    .dropzone.drag{background:#ff6b0020;border-color:#ffb300}
    button{background:#ff6b00;color:white;border:none;padding:14px 32px;font-size:18px;border-radius:12px;cursor:pointer;margin:8px}
    .cancel{background:#ff0044!important}
    .progress{height:32px;background:#333;border-radius:16px;overflow:hidden;margin:20px 0;position:relative}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,#ff6b00,#ffb300);transition:width .4s}
    .stats{font-family:monospace;background:#222;padding:16px;border-radius:12px;margin-top:20px}
    .note{font-size:14px;opacity:0.8;margin-top:20px}
  </style>
</head>
<body>
  <div class="card">
    <h1>Scratch Turbo Optimizer v3.1</h1>
    <p>Drop your .sb3 — get 80–95% smaller instantly<br><b>No huge downloads · Lightning fast · Now with Opus audio!</b></p>
    <div id="drop" class="dropzone">Drop .sb3 here or click</div>
    <div class="progress"><div id="bar" class="bar"></div></div></div>
    <p id="status">Waiting for file...</p>
    <button id="download" style="display:none">Download Optimized.sb3</button>
    <button id="cancel" class="cancel" style="display:none">Cancel</button>
    <div id="stats" class="stats" style="display:none"></div>
    <div class="note">Now uses ultra-efficient Opus audio instead of slow ffmpeg.wasm — loads in &lt;2 seconds!</div>
  </div>

  <script>
    const drop = document.getElementById('drop');
    const status = document.getElementById('status');
    const bar = document.getElementById('bar');
    const downloadBtn = document.getElementById('download');
    const cancelBtn = document.getElementById('cancel');
    const statsDiv = document.getElementById('stats');
    let cancelled = false;
    let opusWorker = null;

    // Pre-init Opus encoder in background (fast, small)
    async function initOpus() {
      if (opusWorker) return;
      opusWorker = new OpusEncoderWorker({bitrate: 32, complexity: 6});
      await opusWorker.init();
    }

    cancelBtn.onclick = () => { cancelled = true; status.textContent = "Cancelled"; bar.style.width = "0%"; };

    drop.ondragover = e => { e.preventDefault(); drop.classList.add('drag'); };
    drop.ondragleave = () => drop.classList.remove('drag');
    drop.ondrop = e => { e.preventDefault(); drop.classList.remove('drag'); processFile(e.dataTransfer.files[0]); };
    drop.onclick = () => {
      const input = document.createElement('input');
      input.type = 'file'; input.accept = '.sb3';
      input.onchange = e => processFile(e.target.files[0]);
      input.click();
    };

    async function processFile(file) {
      if (!file || !file.name.toLowerCase().endsWith('.sb3')) return status.textContent = "Please drop a .sb3 file";

      cancelled = false;
      cancelBtn.style.display = "inline-block";
      downloadBtn.style.display = "none";
      statsDiv.style.display = "none";
      status.textContent = "Loading project...";
      bar.style.width = "5%";

      try {
        await initOpus(); // tiny & fast

        const originalSize = file.size;
        const zip = await JSZip.loadAsync(file);
        const newZip = new JSZip();

        const projectJsonText = await zip.file("project.json").async("text");
        let projectJson = JSON.parse(projectJsonText);

        const entries = Object.keys(zip.files).filter(p => p !== "project.json");
        const assetMap = new Map();
        let processed = 0;

        for (const path of entries) {
          if (cancelled) break;
          const entry = zip.file(path);
          if (!entry) continue;

          const ext = path.split('.').pop().toLowerCase();
          let blob, newExt = ext;

          try {
            if (ext === "svg") {
              const text = await entry.async("text");
              const opt = SVGO.optimize(text, { multipass: true });
              blob = new Blob([opt.data], {type: "image/svg+xml"});
            }
            else if (["png","jpg","jpeg"].includes(ext)) {
              const imgBlob = await entry.async("blob");
              const img = await createImageBitmap(imgBlob);
              const canvas = new OffscreenCanvas(img.width, img.height);
              const ctx = canvas.getContext("2d");
              ctx.drawImage(img, 0, 0);
              blob = await canvas.convertToBlob({type: "image/webp", quality: 80});
              newExt = "webp";
            }
            else if (["wav","mp3"].includes(ext)) {
              const arrayBuffer = await entry.async("arrayBuffer");
              const audioCtx = new AudioContext();
              const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer.slice(0));

              const duration = audioBuffer.duration;
              newExt = duration < 4.0 ? "wav" : "opus";

              if (newExt === "wav") {
                // Keep short sounds as WAV (zero latency)
                const wavBlob = await audioBufferToWavBlob(audioBuffer);
                blob = wavBlob;
              } else {
                // Encode to Opus @ 32kbps mono
                const samples = audioBuffer.getChannelData(0); // mono mix
                const opusData = await opusWorker.encode(samples, audioBuffer.sampleRate);
                blob = new Blob([opusData], {type: "audio/ogg"});
              }
            }
            else {
              blob = await entry.async("blob");
            }

            const hash = md5(await blob.arrayBuffer());
            const newName = hash + "." + newExt;
            assetMap.set(path, newName);
            newZip.file(newName, blob);
          } catch (e) {
            console.warn("Fallback for", path, e);
            newZip.file(path, await entry.async("blob"));
          }

          processed++;
          bar.style.width = `${10 + 85 * (processed / entries.length)}%`;
          status.textContent = `Optimizing assets... (${processed}/${entries.length})`;
        }

        if (cancelled) return;

        // Update project.json references
        projectJson.targets.forEach(target => {
          ["costumes","sounds"].forEach(type => {
            target[type]?.forEach(asset => {
              if (assetMap.has(asset.md5ext)) {
                const n = assetMap.get(asset.md5ext);
                asset.assetId = n.split('.')[0];
                asset.dataFormat = n.split('.')[1];
                asset.md5ext = n;
              }
            });
          });
        });

        newZip.file("project.json", JSON.stringify(projectJson));

        status.textContent = "Zipping final file...";
        bar.style.width = "98%";
        const finalBlob = await newZip.generateAsync({type:"blob", compression:"DEFLATE", compressionLevel: 9});

        const saved = originalSize - finalBlob.size;
        statsDiv.innerHTML = `Original: ${(originalSize/1048576).toFixed(2)} MB → ${(finalBlob.size/1048576).toFixed(2)} MB<br>
                               <b>Saved ${ (saved/1024).toFixed(0) } KB (${((saved/originalSize)*100).toFixed(1)}%)</b><br>
                               <small>Now with Opus audio · No huge downloads!</small>`;
        statsDiv.style.display = "block";

        const url = URL.createObjectURL(finalBlob);
        downloadBtn.onclick = () => {
          const a = document.createElement("a");
          a.href = url;
          a.download = file.name.replace(".sb3", "") + "_TURBO_OPUS.sb3";
          a.click();
        };
        downloadBtn.style.display = "inline-block";

        status.textContent = "Done! Click download";
        bar.style.width = "100%";
        cancelBtn.style.display = "none";
      } catch (err) {
        status.textContent = "Error: " + err.message;
        console.error(err);
      }
    }

    // Helper: convert AudioBuffer to WAV blob
    async function audioBufferToWavBlob(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const format = 1; // PCM
      const bitDepth = 16;

      let result = new DataView(new ArrayBuffer(44 + buffer.length * numChannels * 2));
      let offset = 0;

      function writeString(str) {
        for (let i = 0; i < str.length; i++) {
          result.setUint8(offset++, str.charCodeAt(i));
        }
      }

      function writeUint32(val) { result.setUint32(offset, val, true); offset += 4; }
      function writeUint16(val) { result.setUint16(offset, val, true); offset += 2; }

      writeString('RIFF');
      writeUint32(36 + buffer.length * numChannels * 2);
      writeString('WAVE');
      writeString('fmt ');
      writeUint32(16);
      writeUint16(format);
      writeUint16(numChannels);
      writeUint32(sampleRate);
      writeUint32(sampleRate * numChannels * bitDepth/8);
      writeUint16(numChannels * bitDepth/8);
      writeUint16(bitDepth);
      writeString('data');
      writeUint32(buffer.length * numChannels * 2);

      let channelData = [];
      for (let i = 0; i < numChannels; i++) {
        channelData.push(buffer.getChannelData(i));
      }

      for (let i = 0; i < buffer.length; i++) {
        for (let channel = 0; channel < numChannels; channel++) {
          let sample = Math.max(-1, Math.min(1, channelData[channel][i]));
          sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          result.setInt16(offset, sample, true);
          offset += 2;
        }
      }

      return new Blob([result], { type: 'audio/wav' });
    }
  </script>
</body>
</html>
