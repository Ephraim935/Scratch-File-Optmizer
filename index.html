<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Scratch Turbo Optimizer v8.1 — Drag/Click Fixed</title>
<link rel="icon" href="data:,">
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js"></script>
<style>
  body{margin:0;font-family:system-ui;background:#0f0f0f;color:#fff;height:100vh;display:grid;place-items:center}
  .box{background:#1a1a1a;padding:40px;border-radius:20px;max-width:560px;width:90%;text-align:center;box-shadow:0 20px 40px #000}
  h1{color:#ff6b00;margin:0 0 16px}
  #drop{border:4px dashed #ff6b00;padding:80px 20px;border-radius:16px;margin:24px 0;cursor:pointer;font-size:19px;transition:.3s;position:relative}
  #drop.drag{background:#ff6b0020;border-color:#ffb300}
  button{background:#ff6b00;color:#fff;border:none;padding:14px 32px;font-size:18px;border-radius:12px;cursor:pointer;margin:8px}
  .cancel{background:#ff0044}
  .progress{height:36px;background:#333;border-radius:18px;overflow:hidden;margin:20px 0}
  .bar{height:100%;width:0%;background:linear-gradient(90deg,#ff6b00,#ffb300);transition:.4s}
  .stats{background:#222;padding:16px;border-radius:12px;margin-top:20px;font-family:monospace}
  #fileInput{position:absolute;opacity:0;width:100%;height:100%;cursor:pointer;top:0;left:0}
  #testBtn{background:#00ff00;color:#000;margin:10px}
</style>
</head>
<body>
<div class="box">
  <h1>Scratch Turbo Optimizer v8.1</h1>
  <p>Drop .sb3 → 80–92% smaller instantly<br><b>Fixed drag/click · Report bugs for updates</b></p>
  <button id="testBtn" onclick="alert('JS works!')">Test JS</button>
  <div id="drop">Drop .sb3 here or click<br><small>(Fixed for all browsers)</small>
    <input id="fileInput" type="file" accept=".sb3">
  </div>
  <div class="progress"><div id="bar" class="bar"></div></div>
  <p id="msg">Ready</p>
  <button id="dl" style="display:none">Download Optimized.sb3</button>
  <button id="cancel" class="cancel" style="display:none">Cancel</button>
  <div id="stats" class="stats" style="display:none"></div>
</div>

<script>
// Global prevent defaults (stops browser opens on drag)
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
  document.addEventListener(eventName, e => e.preventDefault());
});

let cancel = false;

document.getElementById("cancel").onclick = () => {
  cancel = true;
  document.getElementById("msg").textContent = "Cancelled";
  document.getElementById("bar").style.width = "0%";
};

const drop = document.getElementById("drop");
const fileInput = document.getElementById("fileInput");

drop.ondragenter = e => { e.preventDefault(); drop.classList.add("drag"); };
drop.ondragover = e => { e.preventDefault(); drop.classList.add("drag"); };
drop.ondragleave = e => { drop.classList.remove("drag"); };
drop.ondrop = e => {
  e.preventDefault();
  drop.classList.remove("drag");
  if (e.dataTransfer.files[0]) process(e.dataTransfer.files[0]);
  else alert("No file dropped – try again!");
};

drop.onclick = () => {
  fileInput.click();
};

fileInput.onchange = e => {
  if (e.target.files[0]) process(e.target.files[0]);
  else alert("No file selected – try drag instead!");
};

async function process(file) {
  if (!file || !file.name.toLowerCase().endsWith(".sb3")) {
    document.getElementById("msg").textContent = "Please select a .sb3 file";
    return;
  }

  cancel = false;
  document.getElementById("cancel").style.display = "inline-block";
  document.getElementById("dl").style.display = "none";
  document.getElementById("stats").style.display = "none";
  msg("Loading project…");
  bar(5);

  try {
    const originalSize = file.size;
    const zip = await JSZip.loadAsync(file);
    const newZip = new JSZip();
    const project = JSON.parse(await zip.file("project.json").async("text"));
    const assetMap = new Map();
    const files = Object.keys(zip.files).filter(f => f !== "project.json");
    let processed = 0;

    for (const path of files) {
      if (cancel) return;
      const entry = zip.file(path);
      if (!entry) continue;

      const ext = path.split(".").pop().toLowerCase();
      let blob = null;
      let newExt = ext;

      // SVG optimization
      if (ext === "svg") {
        let text = await entry.async("text");
        text = text
          .replace(/<\?xml.*?\?>\s*/g,"")
          .replace(/<!DOCTYPE.*?>\s*/g,"")
          .replace(/<!--[\s\S]*?-->/g,"")
          .replace(/<metadata[\s\S]*?<\/metadata>/gi,"")
          .replace(/<title>[\s\S]*?<\/title>/gi,"")
          .replace(/<desc>[\s\S]*?<\/desc>/gi,"")
          .replace(/\s+/g," ")
          .replace(/> </g,"><")
          .replace(/\s*([<>])\s*/g,"$1")
          .trim();
        blob = new Blob([text], {type: "image/svg+xml"});
      }

      // PNG/JPG → WebP
      else if (["png","jpg","jpeg"].includes(ext)) {
        const img = await createImageBitmap(await entry.async("blob"));
        const canvas = new OffscreenCanvas(img.width, img.height);
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        blob = await canvas.convertToBlob({type: "image/webp", quality: 80});
        newExt = "webp";
      }

      // Audio: only downsample short sounds, never fail
      else if (["wav","mp3"].includes(ext)) {
        const arrayBuffer = await entry.async("arrayBuffer");
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let audioBuffer;
        try {
          audioBuffer = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
        } catch(e) {
          blob = await entry.async("blob"); // keep original if unreadable
        }
        if (audioBuffer && audioBuffer.duration < 6) {
          blob = await makeTinyWav(audioBuffer);
          newExt = "wav";
        } else if (!blob) {
          blob = await entry.async("blob"); // fallback
        }
      }

      // Everything else unchanged
      else {
        blob = await entry.async("blob");
      }

      const hash = await md5(await blob.arrayBuffer());
      const newName = hash + "." + newExt;
      assetMap.set(path, newName);
      newZip.file(newName, blob);

      processed++;
      bar(10 + 85 * processed / files.length);
      msg(`Processing… ${processed}/${files.length}`);
    }

    if (cancel) return;

    // Update project.json references
    project.targets.forEach(target => {
      ["costumes","sounds"].forEach(type => {
        target[type]?.forEach(asset => {
          if (assetMap.has(asset.md5ext)) {
            const n = assetMap.get(asset.md5ext);
            asset.assetId = n.split(".")[0];
            asset.dataFormat = n.split(".")[1];
            asset.md5ext = n;
          }
        });
      });
    });

    newZip.file("project.json", JSON.stringify(project));

    msg("Compressing final file…");
    bar(98);
    const finalBlob = await newZip.generateAsync({type:"blob", compression:"DEFLATE", compressionLevel:9});

    const savedKB = Math.round((originalSize - finalBlob.size)/1024);
    document.getElementById("stats").innerHTML = 
      `${(originalSize/1048576).toFixed(2)} MB → ${(finalBlob.size/1048576).toFixed(2)} MB<br>` +
      `<b>Saved ${savedKB} KB — ${((1-finalBlob.size/originalSize)*100).toFixed(1)}% smaller</b>`;
    document.getElementById("stats").style.display = "block";

    const url = URL.createObjectURL(finalBlob);
    document.getElementById("dl").onclick = () => {
      const a = document.createElement("a");
      a.href = url;
      a.download = file.name.replace(/\.sb3$/i, "_TURBO.sb3");
      a.click();
    };
    document.getElementById("dl").style.display = "inline-block";
    msg("Done! Click download");
    bar(100);

  } catch (err) {
    msg("Error: " + err.message);
    console.error(err);
    alert("Bug hit – console has details. Report to me!");
  }
}

function msg(t) { document.getElementById("msg").textContent = t; }
function bar(p) { document.getElementById("bar").style.width = p + "%"; }

// Tiny 16kHz mono WAV for short sounds
async function makeTinyWav(buffer) {
  const offline = new OfflineAudioContext(1, buffer.length, 16000);
  const source = offline.createBufferSource();
  source.buffer = buffer;
  source.connect(offline.destination);
  source.start(0);
  const rendered = await offline.startRendering();

  const len = rendered.length;
  const out = new ArrayBuffer(44 + len*2);
  const view = new DataView(out);
  let pos = 0;
  const writeStr = s => { for (let c of s) view.setUint8(pos++, c.charCodeAt(0)); };
  const writeLE = (v, n) => { for (let i=0; i<n; i++) { view.setUint8(pos++, v & 255); v >>>= 8; }};

  writeStr("RIFF"); writeLE(36 + len*2, 4);
  writeStr("WAVEfmt "); writeLE(16,4); writeLE(1,2); writeLE(1,2); writeLE(16000,4);
  writeLE(32000,4); writeLE(2,2); writeLE(16,2);
  writeStr("data"); writeLE(len*2,4);

  const data = rendered.getChannelData(0);
  for (let i=0; i<len; i++) {
    let s = data[i];
    s = s < 0 ? s * 0x8000 : s * 0x7FFF;
    view.setInt16(pos, s, true);
    pos += 2;
  }
  return new Blob([out], {type: "audio/wav"});
}
</script>
</body>
</html>
